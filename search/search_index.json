{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Quick Start Code on GitHub</p>"},{"location":"#overview","title":"Overview","text":"<p>XDiag is a C++ library for performing Exact Diagonalizations of quantum many-body systems. Key features include optimized combinatorical algorithms for navigating Hilbert spaces, iterative linear algebra algorithms,  shared and distributed memory parallelization.</p>"},{"location":"#gallery","title":"Gallery","text":""},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#basic-examples","title":"Basic examples","text":"<ul> <li> <p>Hello World</p> source <pre><code>#include &lt;xdiag/all.h&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n} catch (std::exception const &amp;e) {\n  traceback(e);\n}\n</code></pre> </li> <li> <p>Ground state energy of a spin chain</p> source <pre><code>#include &lt;xdiag/all.h&gt;\n\nusing namespace xdiag;\n\nint main() try {\n\n  int n_sites = 16;\n  int nup = n_sites / 2;\n\n  // Define the Hilbert space block\n  auto block = Spinhalf(n_sites, nup);\n\n  // Define the nearest-neighbor Heisenberg Hamiltonian\n  BondList bonds;\n  for (int i = 0; i &lt; n_sites; ++i) {\n    bonds &lt;&lt; Bond(\"HB\", \"J\", {i, (i + 1) % n_sites});\n  }\n\n  // Set the coupling constant \"J\" to one\n  bonds[\"J\"] = 1.0;\n\n  // Compute and print the ground state energy\n  double e0 = eigval0(bonds, block);\n  Log(\"Ground state energy: {:.12f}\", e0);\n\n} catch (std::exception const &amp;e) {\n  traceback(e);\n}\n</code></pre> </li> </ul>"},{"location":"examples/#distributed-examples","title":"Distributed examples","text":"<ul> <li> <p>Time-evolution of a \\(t\\)-\\(J\\) model</p> source <pre><code>#include &lt;xdiag/all.h&gt;\n\nusing namespace xdiag;\n\nvoid measure_density(int n_sites, State const &amp;v) {\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n  for (int i = 0; i &lt; n_sites; ++i) {\n    complex sz = innerC(Bond(\"NUMBER\", i), v);\n    if (rank == 0) {\n      printf(\"%.6f \", std::real(sz));\n    }\n  }\n  if (rank == 0) {\n    printf(\"\\n\");\n  }\n}\n\nint main(int argc, char **argv) try {\n  MPI_Init(&amp;argc, &amp;argv);\n\n  int L = 6;\n  int W = 4;\n  double t = 1.0;\n  double J = 0.1;\n  double mu_0 = 10;\n\n  int n_sites = L * W;\n  double precision = 1e-12;\n\n  // Create square lattice t-J model\n  BondList bonds;\n  for (int x = 0; x &lt; L-1; ++x) {\n    for (int y = 0; y &lt; W; ++y) {\n      int nx = (x + 1) % L;\n      int ny = (y + 1) % W;\n\n      int site = x * W + y;\n      int right = nx * W + y;\n      int top = x * W + ny;\n      bonds &lt;&lt; Bond(\"HOP\", \"T\", {site, right});\n      bonds &lt;&lt; Bond(\"EXCHANGE\", \"J\", {site, right});\n      bonds &lt;&lt; Bond(\"HOP\", \"T\", {site, top});\n      bonds &lt;&lt; Bond(\"EXCHANGE\", \"J\", {site, top});\n\n\n\n      if (x &lt; L / 2) {\n    Log(\"x {} y {} site {} t {} r {} +\", x, y, site, top, right);\n        bonds &lt;&lt; Bond(\"NUMBER\", \"MUPLUS\", site);\n      } else {\n    Log(\"x {} y {} site {} t {} r {} -\", x, y, site, top, right);\n        bonds &lt;&lt; Bond(\"NUMBER\", \"MUNEG\", site);\n      }\n    }\n  }\n  bonds[\"T\"] = t;\n  bonds[\"J\"] = J;\n  bonds[\"MUPLUS\"] = mu_0;\n  bonds[\"MUNEG\"] = mu_0;\n\n  auto block = tJDistributed(n_sites, n_sites / 2 - 1, n_sites / 2 - 1);\n\n  XDiagPrint(block);\n\n  Log.set_verbosity(2);\n  tic();\n  auto [e0, v] = eig0(bonds, block);\n  toc(\"gs\");\n\n  bonds[\"MUPLUS\"] = 0;\n  bonds[\"MUNEG\"] = 0;\n\n  measure_density(n_sites, v);\n\n  // Do the time evolution with a step size tau\n  double tau = 0.1;\n  for (int i = 0; i &lt; 40; ++i) {\n    tic();\n    v = time_evolve(bonds, v, tau, precision);\n    toc(\"time evolve\");\n    tic();\n    measure_density(n_sites, v);\n    toc(\"measure\");\n  }\n\n  MPI_Finalize();\n  return EXIT_SUCCESS;\n} catch (std::exception const &amp;e) {\n  traceback(e);\n}\n</code></pre> </li> </ul>"},{"location":"examples/#application-cmakeliststxt","title":"Application CMakeLists.txt","text":"<ul> <li> <p>Normal xdiag library</p> source <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  hello_world\n)\n\nfind_package(xdiag REQUIRED HINTS \"../../install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre> </li> <li> <p>Distributed xdiag library</p> source <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  tj_distributed_time_evolve\n)\n\nfind_package(xdiag_distributed REQUIRED HINTS ../../../install)\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#c-compilation","title":"C++ Compilation","text":"<p>Using XDiag with C++ is a two-step process. First the <code>xdiag</code> library needs to be compiled and installed. Therafter, application codes are compiled in a second step. Here we explain how to compile the library.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A C++ compiler that supports C++17 (<code>g++</code>, <code>clang</code>, or Intel's <code>icpx</code>)</li> <li>git version control system</li> <li>CMake build system generator </li> <li>A linear algebra backend (Blas/Lapack, IntelMKL or Accelerate on OSX)</li> <li>optional HDF5, OpenMP</li> <li>optional MPI for the distributed library</li> </ul>"},{"location":"installation/#basic-compilation","title":"Basic Compilation","text":"<ul> <li> <p>Download the source code using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p> </li> <li> <p>Compile the default library <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre>   By default, the library is now installed in the subdirectory <code>install</code>.</p> </li> <li> <p>Compile the distributed library</p> <p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> </li> </ul>"},{"location":"installation/#advanced-compilation","title":"Advanced Compilation","text":"<ul> <li> <p>Parallel compilation     To speed up the compilation process, the build step can be performed in parallel using the <code>-j</code> flag</p> <pre><code>cmake --build build -j\n</code></pre> </li> <li> <p>Listing compile options</p> <p>The available compilation options can be displayed using <pre><code>cmake -L .\n</code></pre></p> </li> <li> <p>Choosing a certain compiler</p> <p>The compiler (e.g. <code>icpx</code>) can be specified using <pre><code>cmake -S . -B build -D CMAKE_CXX_COMPILER=icpx\n</code></pre></p> <p>Warning</p> <p>If the <code>xdiag</code> library is compiled with a certain compiler, it is advisable to also compile the application codes with the same compiler.</p> </li> <li> <p>Setting the install path</p> <p>In the installation step, the install directory can be set in the following way <pre><code>cmake --install build --prefix /my/install/prefix\n</code></pre></p> </li> <li> <p>Disabling HDF5/OpenMP</p> <p>To disable support for HDF5 or OpenMP support, use <pre><code>cmake -S . -B build -D XDIAG_DISABLE_OPENMP=On -D XDIAG_DISABLE_HDF5=On\n</code></pre></p> </li> <li> <p>Building and running tests</p> <p>To compile and run the testing programs, use <pre><code>cmake -S . -B build -D BUILD_TESTING=On\ncmake --build build\nbuild/tests/tests\n</code></pre></p> </li> </ul>"},{"location":"quickstart/","title":"Quick start","text":""},{"location":"quickstart/#hello-world","title":"Hello World","text":"<p>Let us set up our first program using the <code>xdiag</code> library. For this we need to create two files. The first is the actual <code>C++</code> code.</p> <pre><code>#include &lt;xdiag/all.h&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n} catch (std::exception const &amp;e) {\n  traceback(e);\n}\n</code></pre> <p>The function <code>say_hello()</code> prints out a welcome message, which also contains information which exact XDiag version is used. What is maybe a bit unfamiliar is the <code>try / catch</code> block. XDiag implements a traceback mechanism for runtime errors, which is activated by this idiom. While not stricly necessary here, it is a good practice to make use of this.</p> <p>Now that the application program is written, we next need to set up the compilation instructions using CMake. To do so we create a second file called <code>CMakeLists.txt</code> in the same directory.</p> <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  hello_world\n  LANGUAGES CXX\n)\n\nfind_package(xdiag REQUIRED HINTS \"/path/to/xdiag/install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC xdiag::xdiag)\n</code></pre> <p>You should replace <code>\"/path/to/xdiag/install\"</code> with the appropriate directory where your XDiag library is installed after compilation. This exact <code>CMakeLists.txt</code> file can be used to compile any XDiag application.</p> <p>Info</p> <p>For using the distributed XDiag library the last line of the above <code>CMakeLists.txt</code> should be changed to</p> <pre><code>target_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre> <p>We then compile the application code,</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> <p>and finally run our first <code>xdiag</code> application.</p> <pre><code>./build/main\n</code></pre>"},{"location":"quickstart/#computing-the-ground-state-energy-of-a-spin-chain","title":"Computing the ground state energy of a spin chain","text":"<p>We compute the ground state energy of the \\(S=1/2\\) Heisenberg chain on a periodic chain lattice in one dimension. The Hamiltonian is given by</p> \\[ H = J\\sum_{\\langle i,j \\rangle} \\mathbf{S}_i \\cdot \\mathbf{S}_j\\] <p>where \\(\\mathbf{S}_i = (S_i^x, S_i^y, S_i^z)\\) are the spin \\(S=1/2\\) operators and \\(\\langle i,j \\rangle\\) denotes summation over nearest-meighbor sites \\(i\\) and \\(j\\).</p> <p>The following code, sets up the Hilbert space, defines the Hamiltonian and finally calls an iterative eigenvalue solver to compute the ground state energy.</p> <pre><code>#include &lt;xdiag/all.h&gt;\n\nusing namespace xdiag;\n\nint main() try {\n\n  int n_sites = 16;\n  int nup = n_sites / 2;\n\n  // Define the Hilbert space block\n  auto block = Spinhalf(n_sites, nup);\n\n  // Define the nearest-neighbor Heisenberg Hamiltonian\n  BondList bonds;\n  for (int i = 0; i &lt; n_sites; ++i) {\n    bonds &lt;&lt; Bond(\"HB\", \"J\", {i, (i + 1) % n_sites});\n  }\n\n  // Set the coupling constant \"J\" to one\n  bonds[\"J\"] = 1.0;\n\n  // Compute and print the ground state energy\n  double e0 = eigval0(bonds, block);\n  Log(\"Ground state energy: {:.12f}\", e0);\n\n} catch (std::exception const &amp;e) {\n  traceback(e);\n}\n</code></pre>"}]}