{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Quick Start Code on GitHub</p>"},{"location":"#overview","title":"Overview","text":"<p>XDiag is a C++ library for performing Exact Diagonalizations of quantum many-body systems. Key features include optimized combinatorical algorithms for navigating Hilbert spaces, iterative linear algebra algorithms,  shared and distributed memory parallelization.</p>"},{"location":"#gallery","title":"Gallery","text":""},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#basic-examples","title":"Basic examples","text":"<ul> <li> <p> Hello World</p> <p>Prints out a greeting containing information on the version of the code.</p> <p>source </p> </li> <li> <p> Groundstate energy</p> <p>Computes the ground state energy of a simple Heisenberg spin \\(S=1/2\\) chain</p> <p>source </p> </li> </ul>"},{"location":"examples/#distributed-examples","title":"Distributed examples","text":"<ul> <li> <p> \\(t\\)-\\(J\\) time evolution</p> <p>Computes the time evolution of a state in the \\(t\\)-\\(J\\) model with distributed parallelization</p> <p>source </p> </li> </ul>"},{"location":"examples/#cmakeliststxt-for-applications","title":"CMakeLists.txt for applications","text":"<ul> <li> <p> Normal XDiag</p> <p>Template <code>CMakeLists.txt</code> which can be used to compile applications with the normal XDiag library.</p> <p>source </p> </li> <li> <p> Distributed XDiag</p> <p>Template <code>CMakeLists.txt</code> which can be used to compile applications with the distributed XDiag library.</p> <p>source </p> </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#julia-installation","title":"Julia Installation","text":"<p>Enter the package mode using <code>]</code> in the Julia REPL and add the following two packages <pre><code>add https://github.com/awietek/XDiag_jll.jl.git\nadd https://github.com/awietek/XDiag.jl.git\n</code></pre></p>"},{"location":"installation/#c-compilation","title":"C++ Compilation","text":"<p>Using XDiag with C++ is a two-step process. First the <code>xdiag</code> library needs to be compiled and installed. Therafter, application codes are compiled in a second step. Here we explain how to compile the library.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A C++ compiler that supports C++17 (<code>g++</code>, <code>clang</code>, or Intel's <code>icpx</code>)</li> <li>git version control system</li> <li>CMake build system generator </li> <li>A linear algebra backend (Blas/Lapack, IntelMKL or Accelerate on OSX)</li> <li>optional HDF5, OpenMP</li> <li>optional MPI for the distributed library</li> </ul>"},{"location":"installation/#basic-compilation","title":"Basic Compilation","text":"<ul> <li> <p>Download the source code using git <pre><code>cd /path/to/where/xdiag/should/be\ngit clone https://github.com/awietek/xdiag.git\n</code></pre></p> </li> <li> <p>Compile the default library <pre><code>cd xdiag\ncmake -S . -B build\ncmake --build build\ncmake --install build\n</code></pre>   By default, the library is now installed in the subdirectory <code>install</code>.</p> </li> <li> <p>Compile the distributed library</p> <p>To use the distributed computing features of <code>xdiag</code>, the distributed library has to be built which requires MPI. <pre><code>cd xdiag\ncmake -S . -B build -D XDIAG_DISTRIBUTED=On\ncmake --build build\ncmake --install build\n</code></pre></p> <p>Info</p> <p>It might be necessary to explicitly define MPI compiler, e.g. <code>mpicxx</code> like this <pre><code>cmake -S . -B build -D XDIAG_DISTRIBUTED=On -D CMAKE_CXX_COMPILER=mpicxx\n</code></pre></p> </li> </ul>"},{"location":"installation/#advanced-compilation","title":"Advanced Compilation","text":"<ul> <li> <p>Parallel compilation     To speed up the compilation process, the build step can be performed in parallel using the <code>-j</code> flag</p> <pre><code>cmake --build build -j\n</code></pre> </li> <li> <p>Listing compile options</p> <p>The available compilation options can be displayed using <pre><code>cmake -L .\n</code></pre></p> </li> <li> <p>Choosing a certain compiler</p> <p>The compiler (e.g. <code>icpx</code>) can be specified using <pre><code>cmake -S . -B build -D CMAKE_CXX_COMPILER=icpx\n</code></pre></p> <p>Warning</p> <p>If the <code>xdiag</code> library is compiled with a certain compiler, it is advisable to also compile the application codes with the same compiler.</p> </li> <li> <p>Setting the install path</p> <p>In the installation step, the install directory can be set in the following way <pre><code>cmake --install build --prefix /my/install/prefix\n</code></pre></p> </li> <li> <p>Disabling HDF5/OpenMP</p> <p>To disable support for HDF5 or OpenMP support, use <pre><code>cmake -S . -B build -D XDIAG_DISABLE_OPENMP=On -D XDIAG_DISABLE_HDF5=On\n</code></pre></p> </li> <li> <p>Building and running tests</p> <p>To compile and run the testing programs, use <pre><code>cmake -S . -B build -D BUILD_TESTING=On\ncmake --build build\nbuild/tests/tests\n</code></pre></p> </li> <li> <p>Building the Julia wrapper locally</p> <p>First, get the path to the <code>CxxWrap</code> package of julia. To do so, enter the Julia REPL, <pre><code>julia\n</code></pre> and print the corresponding path using <pre><code>using CxxWrap\nCxxWrap.prefix_path()\n</code></pre> This should print the <code>/path/to/libcxxwrap-julia-prefix</code>. This is then used to configure the cmake compilation. <pre><code>cmake -S . -B build -D XDIAG_JULIA_WRAPPER=On -D CMAKE_PREFIX_PATH=/path/to/libcxxwrap-julia-prefix\ncmake --build build\ncmake --install build\n</code></pre> The julia wrapper library can then be found in the install dir as <code>libxdiagjl.so</code>, (or the corresponding library format on non-Linux systems).</p> </li> </ul>"},{"location":"installation/#building-documentation","title":"Building Documentation","text":"<p>The source files for the documentation can be found in the directory <code>docs</code>. The documentation is built using Material for MKDocs. To work on it locally, it can be served using </p> <pre><code>mkdocs serve\n</code></pre> <p>from the <code>xdiag</code> root source directory. A local build of the documentation can then be accessed in a webbrowser at the adress</p> <pre><code>127.0.0.1:8000\n</code></pre>"},{"location":"quickstart/","title":"Quick start","text":""},{"location":"quickstart/#hello-world","title":"Hello World","text":"<p>Let us set up our first program using the <code>xdiag</code> library. </p> JuliaC++ <pre><code>using XDiag\nsay_hello()\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n  say_hello();\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre> <p>The function <code>say_hello()</code> prints out a welcome message, which also contains information which exact XDiag version is used. In Julia this is all there is to it.</p> <p>For the C++ code we need to create two files to compile the program. The first is the actual <code>C++</code> code. What is maybe a bit unfamiliar is the <code>try / catch</code> block. XDiag implements a traceback mechanism for runtime errors, which is activated by this idiom. While not stricly necessary here, it is a good practice to make use of this.</p> <p>Now that the application program is written, we next need to set up the compilation instructions using CMake. To do so we create a second file called <code>CMakeLists.txt</code> in the same directory.</p> <pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  hello_world\n)\n\nfind_package(xdiag REQUIRED HINTS \"../../install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre> <p>You should replace <code>\"/path/to/xdiag/install\"</code> with the appropriate directory where your XDiag library is installed after compilation. This exact <code>CMakeLists.txt</code> file can be used to compile any XDiag application.</p> <p>Info</p> <p>For using the distributed XDiag library the last line of the above <code>CMakeLists.txt</code> should be changed to</p> <pre><code>target_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre> <p>We then compile the application code,</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> <p>and finally run our first <code>xdiag</code> application.</p> <pre><code>./build/main\n</code></pre>"},{"location":"quickstart/#computing-the-ground-state-energy-of-a-spin-chain","title":"Computing the ground state energy of a spin chain","text":"<p>We compute the ground state energy of the \\(S=1/2\\) Heisenberg chain on a periodic chain lattice in one dimension. The Hamiltonian is given by</p> \\[ H = J\\sum_{\\langle i,j \\rangle} \\mathbf{S}_i \\cdot \\mathbf{S}_j\\] <p>where \\(\\mathbf{S}_i = (S_i^x, S_i^y, S_i^z)\\) are the spin \\(S=1/2\\) operators and \\(\\langle i,j \\rangle\\) denotes summation over nearest-meighbor sites \\(i\\) and \\(j\\).</p> <p>The following code, sets up the Hilbert space, defines the Hamiltonian and finally calls an iterative eigenvalue solver to compute the ground state energy.</p> JuliaC++ <pre><code>using XDiag\n\nlet \n    n_sites = 16;\n    nup = n_sites \u00f7 2;\n    block = Spinhalf(n_sites, nup);\n\n    # Define the nearest-neighbor Heisenberg model\n    bonds = BondList()\n    for i in 1:n_sites\n        bonds += Bond(\"HB\", \"J\", [i-1, i % n_sites])\n    end\n    bonds[\"J\"] = 1.0;\n\n    set_verbosity(2);             # set verbosity for monitoring progress\n    e0 = eigval0(bonds, block);   # compute ground state energy\n\n    println(\"Ground state energy: $e0\");\nend\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n\n  int n_sites = 16;\n  int nup = n_sites / 2;\n  Spinhalf block(n_sites, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  BondList bonds;\n  for (int i = 0; i &lt; n_sites; ++i) {\n    bonds += Bond(\"HB\", \"J\", {i, (i + 1) % n_sites});\n  }\n  bonds[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(bonds, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre>"},{"location":"documentation/","title":"Documentation","text":""},{"location":"documentation/#algorithms","title":"Algorithms","text":"Name Description Language eigval0 Computes the lowest lying eigenvalue of an operator eig0 Computes the lowest lying eigenvalue and eigenvector of an operator"},{"location":"documentation/#blocks","title":"Blocks","text":"Spinhalf Block of a spin \\(S=1/2\\) type Hilbert space tJ Block of a \\(t-J\\) type Hilbert space Electron Block of a Electron type Hilbert space"},{"location":"documentation/#symmetries","title":"Symmetries","text":"Permutation Permutations of indices or lattice sites PermutationGroup A group of permutations Representation A (1D) irreducible representation of a finite group"},{"location":"documentation/#utilities","title":"Utilities","text":"Logging Controling what is written to standard output Timing Measurng wall time straightforwardly XDIAG_SHOW Macro for printing debugging information"},{"location":"documentation/algorithms/eig0/","title":"eig0","text":"<pre><code>eig0(bondlist, block; precision, max_iterations, force_complex, random_seed)\n</code></pre> <p>Computes the lowest lying eigenvalue of an operator.</p> Parameters Name Description Default bondlist BondList defining the bonds of the operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 force_complex whether or not computation should be forced to have complex arithmetic false random_seed random seed for setting up the initial vector 42 Returns Type Description real number lowest lying eigenvalue State groundstate Definition JuliaC++ <pre><code>eig0(bonds::BondList, block::Spinhalf;\n     precision::Real=1e-12, maxiter::Integer=1000,\n     force_complex::Bool=false, seed::Integer=42)\n</code></pre> <pre><code>std::tuple&lt;double, State&gt;\neig0(BondList const &amp;bondlist, block_variant_t const &amp;block,\n     double precision = 1e-12, int64_t max_iterations = 1000,\n     bool force_complex = false, int64_t random_seed = 42);\n</code></pre> <p>Source sparse_diag.hpp</p>"},{"location":"documentation/algorithms/eigval0/","title":"eigval0","text":"<pre><code>eigval0(bondlist, block; precision, max_iterations, force_complex, random_seed)\n</code></pre> <p>Computes the lowest lying eigenvalue of an operator.</p> Parameters Name Description Default bondlist BondList defining the bonds of the operator block block on which the operator is defined precision accuracy of the computed ground state 1e-12 max_iterations maximum number of iterations 1000 force_complex whether or not computation should be forced to have complex arithmetic false random_seed random seed for setting up the initial vector 42 Returns Type Description real number lowest lying eigenvalue Definition JuliaC++ <pre><code>eig0(bonds::BondList, block::Union{Spinhalf,Electron,tJ};\n          precision::Real=1e-12, maxiter::Integer=1000,\n          force_complex::Bool=false, seed::Integer=42)\n</code></pre> <pre><code>double eigval0(BondList const &amp;bondlist, block_variant_t const &amp;block,\n               double precision = 1e-12, int64_t max_iterations = 1000,\n               bool force_complex = false, int64_t random_seed = 42);\n</code></pre> <p>Source sparse_diag.hpp</p>"},{"location":"documentation/blocks/electron/","title":"Electron","text":""},{"location":"documentation/blocks/electron/#constructors","title":"Constructors","text":"<p>Creates a block object for Electron (spinful fermion) type Hilbert spaces. </p> Parameters Name Description n_sites number of sites (integer) n_up number of \"up\" electrons (integer) n_dn number of \"dn\" electrons (integer) group PermutationGroup defining the permutation symmetries irrep Representation defining the irreducible representation of the symmetry group JuliaC++ <pre><code>Electron(n_sites::Integer)\nElectron(n_sites::Integer, n_up::Integer, n_dn::Integer)\nElectron(n_sites::Integer, group::PermutationGroup, irrep::Representation)\nElectron(n_sites::Integer, n_up::Integer, n_dn::Integer, \n         group::PermutationGroup, irrep::Representation)\n</code></pre> <pre><code>Electron(int64_t n_sites);\nElectron(int64_t n_sites, int64_t n_up, int64_t n_dn);\nElectron(int64_t n_sites, PermutationGroup permutation_group,\n         Representation irrep);\nElectron(int64_t n_sites, int64_t n_up, int64_t n_dn, \n         PermutationGroup group, Representation irrep);\n</code></pre>"},{"location":"documentation/blocks/electron/#methods","title":"Methods","text":"n_sites <p>Returns the number of sites of the block.</p> JuliaC++ <pre><code>n_sites(block::Electron)\n</code></pre> <pre><code>int64_t n_sites() const\n</code></pre> size <p>Returns the size of the block, i.e. its dimension.</p> JuliaC++ <pre><code>size(block::Electron)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre>"},{"location":"documentation/blocks/electron/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without number conservation\nblock = Electron(N)\n@show block\n\n# with number conservation\nblock_np = Electron(N, nup, ndn)\n@show block_np\n\n# with symmetries, without number conservation\np1 = Permutation([0, 1, 2, 3])\np2 = Permutation([1, 2, 3, 0])\np3 = Permutation([2, 3, 0, 1])\np4 = Permutation([3, 0, 1, 2])\ngroup = PermutationGroup([p1, p2, p3, p4])\nirrep = Representation([1, -1, 1, -1])\nblock_sym = Electron(N, group, irrep)\n@show block_sym\n\n# with symmetries and number conservation\nblock_sym_np = Electron(N, nup, ndn, group, irrep)\n@show block_sym_np\n\n@show n_sites(block_sym_np)\n@show size(block_sym_np)\n</code></pre> <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without number conservation\nauto block = Electron(N);\nXDIAG_SHOW(block);\n\n// with number conservation\nauto block_np = Electron(N, nup, ndn);\nXDIAG_SHOW(block_np);\n\n// with symmetries, without number conservation\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation({1, -1, 1, -1});\nauto block_sym = Electron(N, group, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and number conservation\nauto block_sym_np = Electron(N, nup, ndn, group, irrep);\nXDIAG_SHOW(block_sym_np);\n\nXDIAG_SHOW(block_sym_np.n_sites());\nXDIAG_SHOW(block_sym_np.size());\n</code></pre> <p>Source electron.hpp</p>"},{"location":"documentation/blocks/spinhalf/","title":"Spinhalf","text":""},{"location":"documentation/blocks/spinhalf/#constructors","title":"Constructors","text":"<p>Creates a block object for spin \\(S=1/2\\) type Hilbert spaces. </p> Parameters Name Description n_sites number of sites (integer) n_up number of \"up\" spin setting spin (integer) group PermutationGroup defining the permutation symmetries irrep Representation defining the irreducible representation of the symmetry group JuliaC++ <pre><code>Spinhalf(n_sites::Integer)\nSpinhalf(n_sites::Integer, n_up::Integer)\nSpinhalf(n_sites::Integer, group::PermutationGroup, irrep::Representation)\nSpinhalf(n_sites::Integer, n_up::Integer, group::PermutationGroup, \n         irrep::Representation)\n</code></pre> <pre><code>Spinhalf(int64_t n_sites);\nSpinhalf(int64_t n_sites, int64_t n_up);\nSpinhalf(int64_t n_sites, PermutationGroup permutation_group,\n         Representation irrep);\nSpinhalf(int64_t n_sites, int64_t n_up, PermutationGroup group,\n         Representation irrep);\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#methods","title":"Methods","text":"n_sites <p>Returns the number of sites of the block.</p> JuliaC++ <pre><code>n_sites(block::Spinhalf)\n</code></pre> <pre><code>int64_t n_sites() const\n</code></pre> size <p>Returns the size of the block, i.e. its dimension.</p> JuliaC++ <pre><code>size(block::Spinhalf)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre>"},{"location":"documentation/blocks/spinhalf/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>N = 4\nnup = 2\n\n# without Sz conservation\nblock = Spinhalf(N)\n@show block\n\n\n# with Sz conservation\nblock_sz = Spinhalf(N, nup)\n@show block_sz\n\n# with symmetries, without Sz\np1 = Permutation([0, 1, 2, 3])\np2 = Permutation([1, 2, 3, 0])\np3 = Permutation([2, 3, 0, 1])\np4 = Permutation([3, 0, 1, 2])\ngroup = PermutationGroup([p1, p2, p3, p4])\nirrep = Representation([1, -1, 1, -1])\nblock_sym = Spinhalf(N, group, irrep)\n@show block_sym\n\n# with symmetries and Sz\nblock_sym_sz = Spinhalf(N, nup, group, irrep)\n@show block_sym_sz\n\n@show n_sites(block_sym_sz)\n@show size(block_sym_sz)\n</code></pre> <pre><code>int N = 4;\nint nup = 2;\n\n// without Sz conservation\nauto block = Spinhalf(N);\nXDIAG_SHOW(block);\n\n// with Sz conservation\nauto block_sz = Spinhalf(N, nup);\nXDIAG_SHOW(block_sz);\n\n// with symmetries, without Sz\nPermutation p1 = {0, 1, 2, 3};\nPermutation p2 = {1, 2, 3, 0};\nPermutation p3 = {2, 3, 0, 1};\nPermutation p4 = {3, 0, 1, 2};\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation({1, -1, 1, -1});\nauto block_sym = Spinhalf(N, group, irrep);\nXDIAG_SHOW(block_sym);\n\n// with symmetries and Sz\nauto block_sym_sz = Spinhalf(N, nup, group, irrep);\nXDIAG_SHOW(block_sym_sz);\n\nXDIAG_SHOW(block_sym_sz.n_sites());\nXDIAG_SHOW(block_sym_sz.size());\n</code></pre> <p>Source spinhalf.hpp</p>"},{"location":"documentation/blocks/tJ/","title":"tJ","text":""},{"location":"documentation/blocks/tJ/#constructors","title":"Constructors","text":"<p>Creates a block object for \\(t-J\\) type Hilbert spaces. </p> Parameters Name Description n_sites number of sites (integer) n_up number of \"up\" electrons (integer) n_dn number of \"dn\" electrons (integer) group PermutationGroup defining the permutation symmetries irrep Representation defining the irreducible representation of the symmetry group JuliaC++ <pre><code>tJ(n_sites::Integer, n_up::Integer, n_dn::Integer)\ntJ(n_sites::Integer, n_up::Integer, n_dn::Integer, \n   group::PermutationGroup, irrep::Representation)\n</code></pre> <pre><code>tJ(int64_t n_sites, int64_t n_up, int64_t n_dn);\ntJ(int64_t n_sites, int64_t n_up, int64_t n_dn, \n   PermutationGroup group, Representation irrep);\n</code></pre>"},{"location":"documentation/blocks/tJ/#methods","title":"Methods","text":"n_sites <p>Returns the number of sites of the block.</p> JuliaC++ <pre><code>n_sites(block::tJ)\n</code></pre> <pre><code>int64_t n_sites() const\n</code></pre> size <p>Returns the size of the block, i.e. its dimension.</p> JuliaC++ <pre><code>size(block::tJ)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre>"},{"location":"documentation/blocks/tJ/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>N = 4\nnup = 2\nndn = 1\n\n# without permutation symmetries\nblock = tJ(N, nup, ndn)\n@show block\n\n# with permutation symmetries\np1 = Permutation([0, 1, 2, 3])\np2 = Permutation([1, 2, 3, 0])\np3 = Permutation([2, 3, 0, 1])\np4 = Permutation([3, 0, 1, 2])\ngroup = PermutationGroup([p1, p2, p3, p4])\nirrep = Representation([1, -1, 1, -1])\nblock_sym = tJ(N, nup, ndn, group, irrep)\n@show block_sym\n\n@show n_sites(block_sym)\n@show size(block_sym)\n</code></pre> <pre><code>int N = 4;\nint nup = 2;\nint ndn = 1;\n\n// without permutation symmetries\nauto block = tJ(N, nup, ndn);\nXDIAG_SHOW(block);\n\n// with permutation symmetries\nauto p1 = Permutation({0, 1, 2, 3});\nauto p2 = Permutation({1, 2, 3, 0});\nauto p3 = Permutation({2, 3, 0, 1});\nauto p4 = Permutation({3, 0, 1, 2});\nauto group = PermutationGroup({p1, p2, p3, p4});\nauto irrep = Representation({1, -1, 1, -1});\nauto block_sym = tJ(N, nup, ndn, group, irrep);\nXDIAG_SHOW(block_sym);\n\nXDIAG_SHOW(block_sym.n_sites());\nXDIAG_SHOW(block_sym.size());\n</code></pre> <p>Source tj.hpp</p>"},{"location":"documentation/symmetries/permutation/","title":"Permutation","text":""},{"location":"documentation/symmetries/permutation/#constructors","title":"Constructors","text":"<p>Creates an Permutation out of an array of integers, e.g. <code>[0, 2, 1, 3]</code>. If the input array is of size <code>N</code> then every number between <code>0</code> and <code>N-1</code> must occur exactly once, otherwise the Permutation is invalid.</p> JuliaC++ <pre><code>Permutation(array::Vector{Int64})\n</code></pre> <pre><code>Permutation(std::vector&lt;int64_t&gt; const &amp;array);\n</code></pre>"},{"location":"documentation/symmetries/permutation/#methods","title":"Methods","text":"inverse <p>Computes the inverse permutation.</p> JuliaC++ <pre><code>inverse(perm::Permutation)\n</code></pre> <pre><code>// As a member function\nPermutation inverse() const;\n\n// As a non-member function\nPermutation inverse(Permutation const &amp;p);\n</code></pre> \"*\" operator <p>Concatenates two permutations by overloading the <code>*</code> operator.</p> JuliaC++ <pre><code>Base.:*(p1::Permutation, p2::Permutation)\n</code></pre> <pre><code>Permutation operator*(Permutation const &amp;p1, Permutation const &amp;p2);\n</code></pre> size <p>Returns the size of the permutation, i.e. the number of indices being permuted.</p> JuliaC++ <pre><code>size(perm::Permutation)\n</code></pre> <pre><code>// As a member function\nint64_t size() const;\n\n// As a non-member function\nint64_t size(Permutation const &amp;p);\n</code></pre>"},{"location":"documentation/symmetries/permutation/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>p1 = Permutation([0, 2, 1, 3])\np2 = Permutation([2, 0, 1, 3])\n\n@show inverse(p1)\n@show p1 * p2\n</code></pre> <pre><code>Permutation p1 = {0, 2, 1, 3};\nPermutation p2 = {2, 0, 1, 3};\n\nXDIAG_SHOW(inverse(p1));\nXDIAG_SHOW(p1*p2);\n</code></pre> <p>Source permutation.hpp</p>"},{"location":"documentation/symmetries/permutation_group/","title":"PermutationGroup","text":""},{"location":"documentation/symmetries/permutation_group/#constructor","title":"Constructor","text":"<p>Creates an PermutationGroup out of a vector of Permutation objects.</p> JuliaC++ <pre><code>PermutationGroup(permutations::Vector{Permutation})\n</code></pre> <pre><code>PermutationGroup(std::vector&lt;Permutation&gt; const &amp;permutations);\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#methods","title":"Methods","text":"n_sites <p>Returns the number of sites on which the permutations of the group acts.</p> JuliaC++ <pre><code>n_sites(group::PermutationGroup)\n</code></pre> <pre><code>int64_t n_sites() const\n</code></pre> size <p>Returns the size of the permutation group, i.e. the number permutations</p> JuliaC++ <pre><code>size(group::PermutationGroup)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> inverse <p>Given an index of a permutation, it returns the index of the inverse permutation.</p> JuliaC++ <pre><code>inverse(group::PermutationGroup, idx::Integer)\n</code></pre> <pre><code>// As a member function\nint64_t inverse(int64_t sym) const;\n</code></pre>"},{"location":"documentation/symmetries/permutation_group/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code># Define a cyclic group of order 3\np1 = Permutation([0, 1, 2])\np2 = Permutation([1, 2, 0])\np3 = Permutation([2, 0, 1])\nC3 = PermutationGroup([p1, p2, p3])\n\n@show size(C3)\n@show n_sites(C3)\n@show inverse(C3, 1) # = 2\n</code></pre> <pre><code>// Define a cyclic group of order 3\nPermutation p1 = {0, 1, 2};\nPermutation p2 = {1, 2, 0};\nPermutation p3 = {2, 0, 1};\nauto C3 = PermutationGroup({p1, p2, p3});\n\nXDIAG_SHOW(C3.size());\nXDIAG_SHOW(C3.n_sites());\nXDIAG_SHOW(C3.inverse(1)); // = 2\n</code></pre> <p>Source permutation_group.hpp</p>"},{"location":"documentation/symmetries/representation/","title":"Representation","text":""},{"location":"documentation/symmetries/representation/#constructors","title":"Constructors","text":"<p>Creates a Representation from a vector of complex numbers</p> JuliaC++ <pre><code>Representation(characters::Vector{&lt;:Number})\n</code></pre> <pre><code>Representation(std::vector&lt;complex&gt; const &amp;characters);\n</code></pre>"},{"location":"documentation/symmetries/representation/#methods","title":"Methods","text":"size <p>Returns the size of the Representation, i.e. the number of characters.</p> JuliaC++ <pre><code>size(irrep::Representation)\n</code></pre> <pre><code>int64_t size() const;\n</code></pre> isreal <p>Returns the whether or not the Representation is real.</p> JuliaC++ <pre><code>isreal(irrep::Representation; precision::Float64=1e-12)\n</code></pre> <pre><code>bool isreal(double precision = 1e-12) const;\n</code></pre> \"*\" operator <p>Multiplies two Representations by overloading the <code>*</code> operator.</p> JuliaC++ <pre><code>Base.:*(p1::Representation, p2::Representation)\n</code></pre> <pre><code>Representation operator*(Representation const &amp;p1, Representation const &amp;p2);\n</code></pre>"},{"location":"documentation/symmetries/representation/#usage-example","title":"Usage Example","text":"JuliaC++ <pre><code>r1 = Representation([1, -1, 1, -1])\nr2 = Representation([1, 1im, -1, -1im])\n\n@show r1 * r2\n</code></pre> <pre><code>Representation r1 = {1, -1, 1, -1};\nRepresentation r2 = {1, 1i, -1, -1i};\n\nXDIAG_SHOW(r1 * r2);\n</code></pre> <p>Source representation.hpp</p>"},{"location":"documentation/utilities/logging/","title":"Logging","text":""},{"location":"documentation/utilities/logging/#setting-the-verbosity","title":"Setting the verbosity","text":"<p>Algorithms implemented in XDiag do not output anything during their execution by default. However, it is typically useful to get some information on how the code is performing and even intermediary results at runtime. For this, the verbosity of the internal XDiag logging can be set using the function <code>set_verbosity</code>, which is defined as </p> JuliaC++ <pre><code>set_verbosity(level::Integer);\n</code></pre> <pre><code>void set_verbosity(int64_t level);\n</code></pre> <p>There are several levels of verbosity, defining how much information is shown.</p> level outputed information 0 no information 1 some information 2 detailed information <p>For example, when computing a ground state energy using the eigval0 function, we can set a higher verbosity level using</p> JuliaC++ <pre><code>set_verbosity(2);\ne0 = eigval0(bonds, block);\n</code></pre> <pre><code>set_verbosity(2);\ndouble e0 = eigval0(bonds, block);\n</code></pre> <p>This will print detailed information, which can look like this</p> <pre><code>Lanczos iteration 1\nMVM: 0.00289 secs\nalpha: -0.2756971549998545\nbeta: 1.7639347562074059\neigs: -0.2756971549998545\nLanczos iteration 2\nMVM: 0.00244 secs\nalpha: -0.7116140394927443\nbeta: 2.3044797637130743\neigs: -2.2710052270892791 1.2836940325966804\nLanczos iteration 3\nMVM: 0.00210 secs\nalpha: -1.2772539678430306\nbeta: 2.6627870395174456\neigs: -3.7522788386927637 -0.6474957945455240 2.1352094709026579\n</code></pre>"},{"location":"documentation/utilities/logging/#log-mechanism-c-only","title":"Log mechanism (C++ only)","text":"<p>Producing nicely formatted output is unfortunately a bit cumbersome in standard C++. For this, the <code>Log</code> mechanism in XDiag can help. To simply write out a line of information you can call,</p> <pre><code>Log(\"hello from the logger\");\n</code></pre> <p>By default, a new line is added. It is also possible to set verbosity by handing the level as the first argument,</p> <pre><code>Log(2, \"hello from the logger only if global verbosity is set to &gt;= 2\");\n</code></pre> <p>This message will only appear if the global verbosity level is set to a value \\(\\geq 2\\). Finally, XDiag also supports formatted output by using the fmtlib. For example, numbers can be formated this way</p> <pre><code>Log(\"pi is around {:.4f} and the answer is {}\", 3.141592, 42);\n</code></pre>"},{"location":"documentation/utilities/logging/#source","title":"Source","text":"<p>logger.hpp</p>"},{"location":"documentation/utilities/timing/","title":"Timing","text":"<p>In standard C++ measuring time is a bit awkward. To quickly monitor the CPU time spent by XDiag by simple functions.</p>"},{"location":"documentation/utilities/timing/#simple-timing-using-tic-toc","title":"Simple timing using tic() / toc()","text":"<p>Similar as in Matlab one can use <code>tic()</code> and <code>toc()</code> to measure the time spent between two points in the code. </p> <pre><code>tic();\ndouble e0 = eigval0(bonds, block);\ntoc();\n</code></pre> <p><code>toc()</code> will output the time spent since the last time <code>tic()</code> has been called.</p>"},{"location":"documentation/utilities/timing/#detailed-timing","title":"Detailed timing","text":"<p>To get the present time, simply call </p> <pre><code>auto time = rightnow();\n</code></pre> <p>A timing (in second) between two time points can be written to output using</p> <pre><code>timing(begin, end);\n</code></pre> <p>This can even be accompanied by a message about what is being timed and a verbosity level (see Logging) can also be set. The full call signature is</p> <pre><code>timing(begin, end, message, level);\n</code></pre> Name Description Default begin starting time computed using <code>rightnow()</code> end end time computed using <code>rightnow()</code> message message string to be prepended to timing \"\" level verbosity level at which timing is printed 0"},{"location":"documentation/utilities/xdiag_show/","title":"Debug printing","text":"<p>For quick debugging in C++, XDiag features a simple macro which outputs the name and content of a variable calles <code>XDIAG_SHOW(x)</code>. For example</p> <pre><code>Spinhalf block(16, 8);\nXDIAG_SHOW(block);\n</code></pre> <p>will write an output similar to</p> <pre><code>block:\n  n_sites  : 16\n  n_up     : 8\n  dimension: 12,870\n  ID       : 0xa9127434d66b9878\n</code></pre> <p>The <code>XDIAG_SHOW(x)</code> macro can be used on any XDiag object and several other standard C++ objects as well.</p>"},{"location":"examples/cmake_distributed/","title":"CMakeLists.txt for the distributed XDiag library","text":"<pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  tj_distributed_time_evolve\n)\n\nfind_package(xdiag_distributed REQUIRED HINTS ../../../install)\nadd_executable(main main.cpp)\ntarget_link_libraries(main PUBLIC xdiag::xdiag_distributed)\n</code></pre>"},{"location":"examples/cmake_normal/","title":"CMakeLists.txt for the normal XDiag library","text":"<pre><code>cmake_minimum_required(VERSION 3.19)\n\nproject(\n  hello_world\n)\n\nfind_package(xdiag REQUIRED HINTS \"../../install\")\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE xdiag::xdiag)\n</code></pre>"},{"location":"examples/hello_world/","title":"Hello world!","text":"JuliaC++ <pre><code>   using XDiag\n   say_hello()\n</code></pre> <pre><code>   #include &lt;xdiag/all.hpp&gt;\n\n   using namespace xdiag;\n\n   int main() try {\n     say_hello();\n   } catch (Error e) {\n     error_trace(e);\n   }\n</code></pre>"},{"location":"examples/spinhalf_chain_e0/","title":"Groundstate energy","text":"JuliaC++ <pre><code>using XDiag\n\nlet \n    n_sites = 16;\n    nup = n_sites \u00f7 2;\n    block = Spinhalf(n_sites, nup);\n\n    # Define the nearest-neighbor Heisenberg model\n    bonds = BondList()\n    for i in 1:n_sites\n        bonds += Bond(\"HB\", \"J\", [i-1, i % n_sites])\n    end\n    bonds[\"J\"] = 1.0;\n\n    set_verbosity(2);             # set verbosity for monitoring progress\n    e0 = eigval0(bonds, block);   # compute ground state energy\n\n    println(\"Ground state energy: $e0\");\nend\n</code></pre> <pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nint main() try {\n\n  int n_sites = 16;\n  int nup = n_sites / 2;\n  Spinhalf block(n_sites, nup);\n\n  // Define the nearest-neighbor Heisenberg model\n  BondList bonds;\n  for (int i = 0; i &lt; n_sites; ++i) {\n    bonds += Bond(\"HB\", \"J\", {i, (i + 1) % n_sites});\n  }\n  bonds[\"J\"] = 1.0;\n\n  set_verbosity(2);                  // set verbosity for monitoring progress\n  double e0 = eigval0(bonds, block); // compute ground state energy\n\n  Log(\"Ground state energy: {:.12f}\", e0);\n\n} catch (Error e) {\n  error_trace(e);\n}\n</code></pre>"},{"location":"examples/tj_distributed_time_evolve/","title":"\\(t\\)-\\(J\\) distributed time evolution","text":"<pre><code>#include &lt;xdiag/all.hpp&gt;\n\nusing namespace xdiag;\n\nvoid measure_density(int n_sites, State const &amp;v) {\n  int rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n  for (int i = 0; i &lt; n_sites; ++i) {\n    complex sz = innerC(Bond(\"NUMBER\", i), v);\n    if (rank == 0) {\n      printf(\"%.6f \", std::real(sz));\n    }\n  }\n  if (rank == 0) {\n    printf(\"\\n\");\n  }\n}\n\nint main(int argc, char **argv) try {\n  MPI_Init(&amp;argc, &amp;argv);\n\n  int L = 6;\n  int W = 4;\n  double t = 1.0;\n  double J = 0.1;\n  double mu_0 = 10;\n\n  int n_sites = L * W;\n  double precision = 1e-12;\n\n  // Create square lattice t-J model\n  BondList bonds;\n  for (int x = 0; x &lt; L-1; ++x) {\n    for (int y = 0; y &lt; W; ++y) {\n      int nx = (x + 1) % L;\n      int ny = (y + 1) % W;\n\n      int site = x * W + y;\n      int right = nx * W + y;\n      int top = x * W + ny;\n      bonds &lt;&lt; Bond(\"HOP\", \"T\", {site, right});\n      bonds &lt;&lt; Bond(\"EXCHANGE\", \"J\", {site, right});\n      bonds &lt;&lt; Bond(\"HOP\", \"T\", {site, top});\n      bonds &lt;&lt; Bond(\"EXCHANGE\", \"J\", {site, top});\n\n\n\n      if (x &lt; L / 2) {\n    Log(\"x {} y {} site {} t {} r {} +\", x, y, site, top, right);\n        bonds &lt;&lt; Bond(\"NUMBER\", \"MUPLUS\", site);\n      } else {\n    Log(\"x {} y {} site {} t {} r {} -\", x, y, site, top, right);\n        bonds &lt;&lt; Bond(\"NUMBER\", \"MUNEG\", site);\n      }\n    }\n  }\n  bonds[\"T\"] = t;\n  bonds[\"J\"] = J;\n  bonds[\"MUPLUS\"] = mu_0;\n  bonds[\"MUNEG\"] = mu_0;\n\n  auto block = tJDistributed(n_sites, n_sites / 2 - 1, n_sites / 2 - 1);\n\n  XDIAG_SHOW(block);\n\n  Log.set_verbosity(2);\n  tic();\n  auto [e0, v] = eig0(bonds, block);\n  toc(\"gs\");\n\n  bonds[\"MUPLUS\"] = 0;\n  bonds[\"MUNEG\"] = 0;\n\n  measure_density(n_sites, v);\n\n  // Do the time evolution with a step size tau\n  double tau = 0.1;\n  for (int i = 0; i &lt; 40; ++i) {\n    tic();\n    v = time_evolve(bonds, v, tau, precision);\n    toc(\"time evolve\");\n    tic();\n    measure_density(n_sites, v);\n    toc(\"measure\");\n  }\n\n  MPI_Finalize();\n  return EXIT_SUCCESS;\n} catch (std::exception const &amp;e) {\n  traceback(e);\n}\n</code></pre>"}]}